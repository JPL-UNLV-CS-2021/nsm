{"initialPath": ["Active"], "variables": [{"name": "m_timeEvt", "type": "QP::QTimeEvt", "visibility": "0x02", "properties": "0x00"}, {"name": "instance", "type": "Blinky", "visibility": "0x00", "properties": "0x01"}, {"name": "flag", "type": "std::uint32_t", "visibility": "0x00", "properties": "0x00"}, {"name": "AO_Blinky", "type": "QP::QActive * const", "visibility": "0x00", "properties": "0x00"}], "states": [{"name": "Active", "parent": "Null", "entryFunctions": ["BSP::ledOff();", "flag = 0;"], "exitFunctions": [], "transitions": [{"trigger": "TIMEOUT", "target": "Scanning", "action": ""}], "initialTransition": {}, "junction": {}}, {"name": "Scanning", "parent": "Null", "entryFunctions": ["BSP::ledOn();"], "exitFunctions": [], "transitions": [{"trigger": "TIMEOUT", "target": "Active", "action": ""}], "initialTransition": {}, "junction": {"trigger": "JUNCTION_EVENT", "action": "BSP::makeNoise();", "guard": "flag == 1", "iftarget": "Active", "ifaction": "BSP::makeEvilNoise();", "elsetarget": "ModeZ", "elseaction": ""}}, {"name": "ModeZ", "parent": "ModeY", "entryFunctions": ["BSP::ledBlue();"], "exitFunctions": [], "transitions": [{"trigger": "LOOP_EVENT", "target": "Scanning", "action": ""}, {"trigger": "ARM_ROCKETS", "target": "STAGE1BOOSTERS", "action": ""}], "initialTransition": {}, "junction": {}}, {"name": "ModeY", "parent": "ModeX", "entryFunctions": ["BSP::ledGreen();", "flag = 1;"], "exitFunctions": [], "transitions": [], "initialTransition": {"target": "ModeZ"}, "junction": {}}, {"name": "ModeX", "parent": "Null", "entryFunctions": ["BSP::ledRed();"], "exitFunctions": [], "transitions": [{"trigger": "TIMEOUT", "target": "Active", "action": ""}], "initialTransition": {"target": "ModeY"}, "junction": {}}, {"name": "STAGE1BOOSTERS", "parent": "Null", "entryFunctions": [], "exitFunctions": [], "transitions": [{"trigger": "TIMEOUT", "target": "Scanning", "action": "BSP::ledOff();"}], "initialTransition": {}, "junction": {}}], "events": ["TIMEOUT", "JUNCTION_EVENT", "LOOP_EVENT", "ARM_ROCKETS"], "files": {"blinky.cpp": "#include \"qpcpp.hpp\" // QP/C++ framework API\n#include \"bsp.hpp\"   // Board Support Package interface\n\nusing namespace QP;\n\n// ask QM to declare the Blinky class ----------------------------------------\n$declare${AOs::Blinky}\n\n// opaque pointer to the Blinky active object --------------------------------\n$define${AOs::AO_Blinky}\n\n// ask QM to define the Blinky class (including the state machine) -----------\n$define${AOs::Blinky}", "bsp.hpp": "#ifndef BSP_HPP\n#define BSP_HPP\n\n// a very simple Board Support Package (BSP) -------------------------------\nclass BSP {\npublic:\n    enum { TICKS_PER_SEC = 100 }; // numer of clock ticks in a second\n    static void init(void);\n    static void ledOff(void);\n    static void ledOn(void);\n    static void ledRed(void);\n    static void ledGreen(void);\n    static void ledBlue(void);\n    static void makeNoise(void);\n    static void makeEvilNoise(void);\n};\n\nenum BlinkySignals {\n    TIMEOUT_SIG = QP::Q_USER_SIG, // offset the first signal\n    MAX_SIG\n};\n\n// active object(s) used in this application -------------------------------\n$declare${AOs::AO_Blinky}\n\n#endif // BSP_HPP", "bsp.cpp": "#include \"qpcpp.hpp\"  // QP/C++ framework API\n#include \"bsp.hpp\"    // Board Support Package interface\n#include <iostream>   // for cout/cerr\n#include <cstdlib>    // for exit()\n\nusing namespace std;\nusing namespace QP;\n\nvoid BSP::init(void)   {\n    cout << \"Simple Blinky example\\nQP/C++ version: \"\n         << QP_VERSION_STR\n         << \"\\nPress Ctrl-C to quit...\"\n         << endl; // print QP version\n}\nvoid BSP::ledOff(void) { cout << \"LED OFF\" << endl; }\nvoid BSP::ledOn(void)  { cout << \"LED ON\" << endl;  }\nvoid BSP::ledRed(void) { cout << \"LED RED\" << endl; }\nvoid BSP::ledGreen(void) { cout << \"LED GREEN\" << endl; }\nvoid BSP::ledBlue(void) { cout << \"LED BLUE\" << endl; }\nvoid BSP::makeNoise(void)  { cout << \"BEEP BOOP\" << endl;  }\nvoid BSP::makeEvilNoise(void)  { cout << \"MUAH HA HA\" << endl;  }\n// callback functions needed by the framework --------------------------------\nvoid QF::onStartup(void) {}\nvoid QP::QF::onCleanup(void) {}\nvoid QP::QF_onClockTick(void) {\n    QF::TICK_X(0U, 0); // QF clock tick processing for rate 0\n}\nvoid Q_onAssert(char const * const module, int loc) {\n    cerr << \"Assertion failed in \" <<  module << \":\" << loc << endl;\n    exit(-1);\n}", "main.cpp": "#include \"qpcpp.hpp\" // QP/C++ framework API\n#include \"bsp.hpp\"   // Board Support Package interface\n\nusing namespace QP;\n\n// the main function ---------------------------------------------------------\nint main() {\n    QF::init();  // initialize the framework\n    BSP::init(); // initialize the BSP\n\n    // start the Blinky active object\n    static QEvt const *blinky_queueSto[10]; // event queue buffer for Blinky\n    AO_Blinky->start(1U, // priority of the active object\n        blinky_queueSto, // event queue buffer\n        Q_DIM(blinky_queueSto), // the length of the buffer\n        (void *)0, 0U);  // private stack (not used on the desktop)\n\n    return QF::run(); // let the framework run the application\n}", "Makefile": "# Makefile for building QP/C++ application on Windows and POSIX hosts\n#\n# examples of invoking this Makefile:\n# building configurations: Debug (default), Release, and Spy\n# make\n# make CONF=rel\n# make CONF=spy\n# make clean   # cleanup the build\n# make CONF=spy clean   # cleanup the build\n#\n# NOTE:\n# To use this Makefile on Windows, you will need the GNU make utility, which\n# is included in the QTools collection for Windows, see:\n#    http://sourceforge.net/projects/qpc/files/QTools/\n#\n\n#-----------------------------------------------------------------------------\n# project name:\n#\nPROJECT := blinky\n\n#-----------------------------------------------------------------------------\n# project directories:\n#\n\n# list of all source directories used by this project\nVPATH := . \\\n\n# list of all include directories needed by this project\nINCLUDES := -I. \\\n\n# location of the QP/C framework (if not provided in an env. variable)\nifeq ($(QPCPP),)\nQPCPP := ../../..\nendif\n\n#-----------------------------------------------------------------------------\n# project files:\n#\n\n# C source files...\nC_SRCS :=\n\n# C++ source files...\nCPP_SRCS := \\\n    blinky.cpp \\\n    bsp.cpp \\\n    main.cpp\n\nLIB_DIRS  :=\nLIBS      :=\n\n# defines...\n# QP_API_VERSION controls the QP API compatibility; 9999 means the latest API\nDEFINES   := -DQP_API_VERSION=9999\n\nifeq (,$(CONF))\n    CONF := dbg\nendif\n\n#-----------------------------------------------------------------------------\n# add QP/C++ framework (depends on the OS this Makefile runs on):\n#\nifeq ($(OS),Windows_NT)\n\n# NOTE:\n# For Windows hosts, you can choose:\n# - the single-threaded QP/C++ port (win32-qv) or\n# - the multithreaded QP/C++ port (win32).\n#\nQP_PORT_DIR := $(QPCPP)/ports/win32-qv\n#QP_PORT_DIR := $(QPCPP)/ports/win32\nLIB_DIRS += -L$(QP_PORT_DIR)/$(CONF)\nLIBS     += -lqp -lws2_32\n\nelse\n\n# NOTE:\n# For POSIX hosts (Linux, MacOS), you can choose:\n# - the single-threaded QP/C++ port (win32-qv) or\n# - the multithreaded QP/C++ port (win32).\n#\nQP_PORT_DIR := $(QPCPP)/ports/posix-qv\n#QP_PORT_DIR := $(QPCPP)/ports/posix\n\nCPP_SRCS += \\\n    qep_hsm.cpp \\\n    qep_msm.cpp \\\n    qf_act.cpp \\\n    qf_actq.cpp \\\n    qf_defer.cpp \\\n    qf_dyn.cpp \\\n    qf_mem.cpp \\\n    qf_ps.cpp \\\n    qf_qact.cpp \\\n    qf_qeq.cpp \\\n    qf_qmact.cpp \\\n    qf_time.cpp \\\n    qf_port.cpp\n\nQS_SRCS := \\\n    qs.cpp \\\n    qs_64bit.cpp \\\n    qs_rx.cpp \\\n    qs_fp.cpp \\\n    qs_port.cpp\n\nLIBS += -lpthread\n\nendif\n\n#============================================================================\n# Typically you should not need to change anything below this line\n\nVPATH    += $(QPCPP)/src/qf $(QP_PORT_DIR)\nINCLUDES += -I$(QPCPP)/include -I$(QPCPP)/src -I$(QP_PORT_DIR)\n\n#-----------------------------------------------------------------------------\n# GNU toolset:\n#\n# NOTE:\n# GNU toolset (MinGW) is included in the QTools collection for Windows, see:\n#     http://sourceforge.net/projects/qpc/files/QTools/\n# It is assumed that %QTOOLS%\\bin directory is added to the PATH\n#\nCC    := gcc\nCPP   := g++\n#LINK  := gcc    # for C programs\nLINK  := g++   # for C++ programs\n\n#-----------------------------------------------------------------------------\n# basic utilities (depends on the OS this Makefile runs on):\n#\nifeq ($(OS),Windows_NT)\n    MKDIR      := mkdir\n    RM         := rm\n    TARGET_EXT := .exe\nelse ifeq ($(OSTYPE),cygwin)\n    MKDIR      := mkdir -p\n    RM         := rm -f\n    TARGET_EXT := .exe\nelse\n    MKDIR      := mkdir -p\n    RM         := rm -f\n    TARGET_EXT :=\nendif\n\n#-----------------------------------------------------------------------------\n# build configurations...\n\nifeq (rel, $(CONF)) # Release configuration ..................................\n\nBIN_DIR := build_rel\n# gcc options:\nCFLAGS  = -c -O3 -fno-pie -std=c99 -pedantic -Wall -Wextra -W \\\n    $(INCLUDES) $(DEFINES) -DNDEBUG\n\nCPPFLAGS = -c -O3 -fno-pie -std=c++11 -pedantic -Wall -Wextra \\\n    -fno-rtti -fno-exceptions \\\n    $(INCLUDES) $(DEFINES) -DNDEBUG\n\nelse ifeq (spy, $(CONF))  # Spy configuration ................................\n\nBIN_DIR := build_spy\n\nCPP_SRCS += $(QS_SRCS)\nVPATH    += $(QPCPP)/src/qs\n\n# gcc options:\nCFLAGS  = -c -g -O -fno-pie -std=c99 -pedantic -Wall -Wextra -W \\\n    $(INCLUDES) $(DEFINES) -DQ_SPY\n\nCPPFLAGS = -c -g -O -fno-pie -std=c++11 -pedantic -Wall -Wextra \\\n    -fno-rtti -fno-exceptions \\\n    $(INCLUDES) $(DEFINES) -DQ_SPY\n\nelse # default Debug configuration .........................................\n\nBIN_DIR := build\n\n# gcc options:\nCFLAGS  = -c -g -O -fno-pie -std=c99 -pedantic -Wall -Wextra -W \\\n    $(INCLUDES) $(DEFINES)\n\nCPPFLAGS = -c -g -O -fno-pie -std=c++11 -pedantic -Wall -Wextra \\\n    -fno-rtti -fno-exceptions \\\n    $(INCLUDES) $(DEFINES)\n\nendif  # .....................................................................\n\nLINKFLAGS := -no-pie\n\n#-----------------------------------------------------------------------------\nC_OBJS       := $(patsubst %.c,%.o,   $(C_SRCS))\nCPP_OBJS     := $(patsubst %.cpp,%.o, $(CPP_SRCS))\n\nTARGET_EXE   := $(BIN_DIR)/$(PROJECT)$(TARGET_EXT)\nC_OBJS_EXT   := $(addprefix $(BIN_DIR)/, $(C_OBJS))\nC_DEPS_EXT   := $(patsubst %.o,%.d, $(C_OBJS_EXT))\nCPP_OBJS_EXT := $(addprefix $(BIN_DIR)/, $(CPP_OBJS))\nCPP_DEPS_EXT := $(patsubst %.o,%.d, $(CPP_OBJS_EXT))\n\n# create $(BIN_DIR) if it does not exist\nifeq (\"$(wildcard $(BIN_DIR))\",\"\")\n$(shell $(MKDIR) $(BIN_DIR))\nendif\n\n#-----------------------------------------------------------------------------\n# rules\n#\n\nall: $(TARGET_EXE)\n\n$(TARGET_EXE) : $(C_OBJS_EXT) $(CPP_OBJS_EXT)\n    $(CPP) $(CPPFLAGS) $(QPCPP)/include/qstamp.cpp -o $(BIN_DIR)/qstamp.o\n    $(LINK) $(LINKFLAGS) $(LIB_DIRS) -o $@ $^ $(BIN_DIR)/qstamp.o $(LIBS)\n\n$(BIN_DIR)/%.d : %.c\n    $(CC) -MM -MT $(@:.d=.o) $(CFLAGS) $< > $@\n\n$(BIN_DIR)/%.d : %.cpp\n    $(CPP) -MM -MT $(@:.d=.o) $(CPPFLAGS) $< > $@\n\n$(BIN_DIR)/%.o : %.c\n    $(CC) $(CFLAGS) $< -o $@\n\n$(BIN_DIR)/%.o : %.cpp\n    $(CPP) $(CPPFLAGS) $< -o $@\n\n.PHONY : clean show\n\n# include dependency files only if our goal depends on their existence\nifneq ($(MAKECMDGOALS),clean)\n  ifneq ($(MAKECMDGOALS),show)\n-include $(C_DEPS_EXT) $(CPP_DEPS_EXT)\n  endif\nendif\n\n.PHONY : clean show\n\nclean :\n    -$(RM) $(BIN_DIR)/*.o \\\n    $(BIN_DIR)/*.d \\\n    $(TARGET_EXE)\n\nshow :\n    @echo PROJECT      = $(PROJECT)\n    @echo TARGET_EXE   = $(TARGET_EXE)\n    @echo VPATH        = $(VPATH)\n    @echo C_SRCS       = $(C_SRCS)\n    @echo CPP_SRCS     = $(CPP_SRCS)\n    @echo C_DEPS_EXT   = $(C_DEPS_EXT)\n    @echo C_OBJS_EXT   = $(C_OBJS_EXT)\n    @echo C_DEPS_EXT   = $(C_DEPS_EXT)\n    @echo CPP_DEPS_EXT = $(CPP_DEPS_EXT)\n    @echo CPP_OBJS_EXT = $(CPP_OBJS_EXT)\n    @echo LIB_DIRS     = $(LIB_DIRS)\n    @echo LIBS         = $(LIBS)\n    @echo DEFINES      = $(DEFINES)\n\n"}}